Recapping the concepts learnt for future reference.

Day 1: 
Used: basic string processing (get 1st and last digits of string, or replace digit spellings with actual digit)
Time taken: ~1h on problem A, ~2h on problem B
Difficulty: 1 / 10 for problem A, 3 / 10 for problem B (in terms of added difficulty)

Day 2:
Used: regex (process string from "3 blue, 1 red, 2 green" to ["3","1","2"]). had to learn regex, but was very easy to apply
Time taken: ~1h on problem A, ~10 mins on problem B
Difficulty: 1 / 10 for problem A, 1 / 10 for problem B

Day 3:
Used: regex + Kernel processing / rudimentary BFS (search surroundings of special characters, then get entire string if it touches special character)
Time taken: ~2h on problem A, ~3h on problem B
Difficulty: 4 / 10 for problem A, 7 / 10 for problem B

Day 4:
Used: basic string processing, recursion + memoization
Time taken: ~1h on problem A, ~2h on problem B
Difficulty: 1 / 10 for problem A, 4 / 10 for problem B

Day 5:
Used: my sanity, composite mappings, efficient mapping algorithm from one interval of integers to another.
Time taken: ~1h on problem A, ~5h on problem B
Difficulty: 3 / 10 for problem A, 8 / 10 for problem B

Day 6:
Used: very basic looping and string processing. nothing much was learnt.
Time taken: ~5 mins on problem A, ~3 mins on problem B
Difficulty: 1 / 10 for problem A, 1 / 10 for problem B

Day 7:
Used: basic logic to classify hand combos in a variant of poker. list comprehension was helpful too.
Time taken: ~40 mins on problem A, ~20 mins on problem B
Difficulty: 3 / 10 for problem A, 3 / 10 for problem B

Day 8:
Used: LCM on a special graph with disjoint, zero offset cycles to determine when a flag was reached (ends with "Z")
Time taken: ~1h on problem A, ~1h on problem B
Difficulty: 3 / 10 for problem A, 5 / 10 for problem B

Day 9:
Used: simple application of recursion to extrapolate an AP-like sequence
Time taken: ~8 mins on problem A, ~3 mins of problem B
Difficulty: 1 / 10 for problem A, 1 / 10 for problem B

Day 10:
Used: learned the point in polygon method and winding path algorithm to determine if a point is within the polygon
Used: alternative methods learnt were the shoelace method and flood filling an extended maze
Time taken: ~2h on problem A, ~3h on problem B
Difficulty: 5 / 10 for problem A, 8 / 10 for problem B

Day 11:
Used: understanding of Manhattan distances
Time taken: ~1h on problem A, ~1h on problem B
Difficulty: 3 / 10 for problem A, 3 / 10 for problem B

Day 12:
Used: Dynamic Programming + Memoization
Time taken: ~2h on problem A, ~20 mins on problem B
Difficulty: 3 / 10 for problem A, 4 / 10 for problem B

Day 13:
Used: Some numpy 2d array functionality.
Time taken: ~1h30 on problem A, ~1h on problem B
Difficulty: 4 / 10 for problem A, 4 / 10 for problem B 

Day 14:
Used: numpy magic to move some rocks around, but could have used logic optimisations by converting absolute to relative cardinal directions. for example, tilting west while facing south would simply be tilting clockwise.
Used: cycle tracking to determine future state by storing entire mazes, but could have optimised memory usage by using cycle tracking of integers but with repeats possible
Time taken: a long time (~5h?)
Difficulty: 4 / 10 for problem A, 7 / 10 for problem B

Day 15:
Used: basic implementation of a given hashing algorithm
Time taken: ~10m on problem A, ~30m on problem B
Difficulty: 1 / 10 for problem A, 2 / 10 for problem B

Day 16:
Used: novel context understanding + basic out-of-bounds checking
Time taken: ~2h
Difficulty: 4 / 10 for problem A, 2 / 10 for problem B

Day 17:
Used: modified Dijkstra's algorithm
Time taken: ~2 days (first time learning and implementation of graph traversal algorithms)
Difficulty: 10 / 10 for problem A, 3 / 10 for problem B

Day 18:
Used: Shoelace theorem + Pick's theorem
Time taken: ~1h on problem A, ~5m on problem B
Difficulty: 4 / 10 for problem A, 0 / 10 for problem B (same algorithm)

Day 19:
Used: integer interval mapping from day 5, applied to a 4D context
Time taken: ~1h on problem A, ~4h on problem B
Difficulty: 4 / 10 for problem A, 8 / 10 for problem B

Day 20:
Used: applied context of a NAND and NOT gate network to determine / predict future state of a terminal NAND gate with LCM (like day 5)
Time taken: ~1h on problem A, ~2h on problem B
Difficulty: 4 / 10 for problem A, 6 / 10 for problem B